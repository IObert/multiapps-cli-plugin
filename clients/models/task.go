package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/xml"

	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/validate"
)

type TaskProgressMessages struct {
	ProgressMessages []*ProgressMessage `xml:"ProgressMessage,omitempty"`
}

// Task Task element represents runtime information about SL processes. All kinds of operations comprising an SL processes are considered to be tasks during the execution. This applies to the top level processes like system update in the same way as to a single operation like copy file
// swagger:model Task
type Task struct {
	XMLName xml.Name `xml:"http://www.sap.com/lmsl/slp Task"`

	// description
	Description string `xml:"description,omitempty"`

	// display name
	DisplayName string `xml:"displayName,omitempty"`

	// error
	Error strfmt.URI `xml:"error,omitempty"`

	// external info
	ExternalInfo strfmt.URI `xml:"externalInfo,omitempty"`

	// finished at
	FinishedAt SlpTimestamp `xml:"finishedAt,omitempty"`

	// id
	// Required: true
	ID *string `xml:"id"`

	// logs
	Logs strfmt.URI `xml:"logs,omitempty"`

	// parent
	Parent string `xml:"parent,omitempty"`

	// progress
	Progress int32 `xml:"progress,omitempty"`

	// progress messages
	ProgressMessages TaskProgressMessages `xml:"progressMessages,omitempty"`

	// refresh rate
	RefreshRate int32 `xml:"refreshRate,omitempty"`

	// started at
	StartedAt SlpTimestamp `xml:"startedAt,omitempty"`

	// status
	// Required: true
	Status SlpTaskState `xml:"status"`

	// technical name
	// Required: true
	TechnicalName *string `xml:"technicalName"`

	// type
	// Required: true
	Type SlpTaskType `xml:"type"`
}

// Validate validates this task
func (m *Task) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProgressMessages(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTechnicalName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Task) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *Task) validateProgressMessages(formats strfmt.Registry) error {

	if swag.IsZero(m.ProgressMessages) { // not required
		return nil
	}

	for i := 0; i < len(m.ProgressMessages.ProgressMessages); i++ {

		if swag.IsZero(m.ProgressMessages.ProgressMessages[i]) { // not required
			continue
		}

		if m.ProgressMessages.ProgressMessages[i] != nil {

			if err := m.ProgressMessages.ProgressMessages[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *Task) validateStatus(formats strfmt.Registry) error {

	if err := m.Status.Validate(formats); err != nil {
		return err
	}

	return nil
}

func (m *Task) validateTechnicalName(formats strfmt.Registry) error {

	if err := validate.Required("technicalName", "body", m.TechnicalName); err != nil {
		return err
	}

	return nil
}

func (m *Task) validateType(formats strfmt.Registry) error {

	if err := m.Type.Validate(formats); err != nil {
		return err
	}

	return nil
}
